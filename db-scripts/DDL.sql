/*
|-------------------------------------------|
|       DATABASE SYSTEMS - SEMESTER PROJECT |
|   Muhammad Farjad Ilyas   -   18I-0436    |
|   Omar Hayat              -   18I-0511    |
|   Saif Ullah Dar          -   18I-0599    |
|-------------------------------------------|
*/

set pagesize 1500
set linesize 1200
set timing on
SET SERVEROUTPUT ON
ALTER SESSION SET NLS_DATE_FORMAT = 'DD/MM/YYYY';





/*----------------------- [[ DDL SECTION ]]-------------------------------*/





/*----------------------- [[ PERSON DDL ]] --------------------------*/

CREATE TABLE PERSON
(
    CNIC VARCHAR2(13),
    F_NAME VARCHAR2(32),
    L_NAME VARCHAR2(32),
    CONTACT_NO VARCHAR2(15),
    GENDER CHAR(1) NOT NULL,
    EMAIL VARCHAR2(255),
    P_TYPE  NUMERIC(1),
    CHECK (P_TYPE BETWEEN 0 AND 2 OR P_TYPE = NULL),
    PRIMARY KEY(CNIC)
);


/*----------------------- [[ STAFF DDL ]] --------------------------*/

CREATE TABLE STAFF
(
    STAFF_ID INTEGER,
    CNIC VARCHAR2(13) NOT NULL,
    CITY VARCHAR2(32),
    AREA VARCHAR2(32),
    STREET VARCHAR2(16),
    JOB_TYPE VARCHAR(10) DEFAULT 'TEACHER',
    UNIQUE(CNIC),
    PRIMARY KEY(STAFF_ID),
    FOREIGN KEY (CNIC) REFERENCES PERSON(CNIC)
);


/*----------------------- [[ PARENT DDL ]] --------------------------*/

CREATE TABLE PARENT
(
    PARENT_ID INTEGER,
    CNIC VARCHAR2(13) NOT NULL,
    UNIQUE(CNIC),
    PRIMARY KEY(PARENT_ID),
    FOREIGN KEY (CNIC) REFERENCES PERSON(CNIC)
);


/*----------------------- [[ PARENT_HISTORY DDL ]] --------------------------*/

CREATE TABLE PARENT_HISTORY
(
    PARENT_ID INTEGER,
    HISTORY_ID INTEGER,
    CNIC VARCHAR2(13) NOT NULL,
    F_NAME VARCHAR2(32),
    L_NAME VARCHAR2(32),
    CONTACT_NO VARCHAR2(15),
    GENDER CHAR(1) NOT NULL,
    EMAIL VARCHAR2(255),
    PRIMARY KEY(PARENT_ID, HISTORY_ID),
    FOREIGN KEY(PARENT_ID) REFERENCES PARENT(PARENT_ID)
);


/*----------------- [[ PERSON INSERT & UPDATE TRIGGERS*/

CREATE OR REPLACE TRIGGER PERSON_INSERT
    AFTER INSERT ON PERSON
    FOR EACH ROW
DECLARE
    CUR_P_ID INTEGER;
BEGIN

    /*INSERTING INTO SUBTYPE TABLE BASED ON P_TYPE*/
    IF :NEW.P_TYPE IN (0,2) THEN
        INSERT INTO STAFF(STAFF_ID, CNIC)
        VALUES(1, :NEW.CNIC);
    END IF;

    IF :NEW.P_TYPE IN (1,2) THEN
        INSERT INTO PARENT(PARENT_ID, CNIC)
        VALUES(1, :NEW.CNIC);

        SELECT NVL(P.PARENT_ID,-1) INTO CUR_P_ID
        FROM PARENT P
        WHERE P.CNIC = :NEW.CNIC;

        INSERT INTO PARENT_HISTORY
        VALUES(CUR_P_ID, 0, :NEW.CNIC, :NEW.F_NAME, :NEW.L_NAME, :NEW.CONTACT_NO, :NEW.GENDER, :NEW.EMAIL);
    END IF;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Error! Insert failed in Trigger: PERSON_INSERT');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error! Unhandled exception in Trigger: PERSON_INSERT.');
END;
/

CREATE OR REPLACE TRIGGER PERSON_UPDATE
    AFTER UPDATE ON PERSON
    FOR EACH ROW
DECLARE
    CUR_P_ID INTEGER;
BEGIN
    /*RECORD UPDATE IN PARENT_HISTORY IF PERSON IS A PARENT*/

    IF :OLD.P_TYPE > 0 THEN
        SELECT NVL(P.PARENT_ID,-1) INTO CUR_P_ID
        FROM PARENT P
        WHERE P.CNIC = :OLD.CNIC;

        INSERT INTO PARENT_HISTORY
        VALUES(CUR_P_ID, 0, :NEW.CNIC, :NEW.F_NAME, :NEW.L_NAME, :NEW.CONTACT_NO, :NEW.GENDER, :NEW.EMAIL);
    END IF;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Error! No data found in Trigger: PERSON_UPDATE');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error! Unhandled exception in Trigger: PERSON_UPDATE');
END;
/



/*----------------- [[ STAFF INSERT TRIGGER*/

CREATE SEQUENCE STAFF_ID_SEQ START WITH 2000;

CREATE OR REPLACE TRIGGER STAFF_ON_INSERT
    BEFORE INSERT ON STAFF
    FOR EACH ROW
BEGIN
    :NEW.STAFF_ID := STAFF_ID_SEQ.nextval;
END;
/



/*------------------ [[ PARENT INSERT TRIGGER*/

CREATE SEQUENCE PARENT_ID_SEQ START WITH 1000;

CREATE OR REPLACE TRIGGER PARENT_ON_INSERT
    BEFORE INSERT ON PARENT
    FOR EACH ROW
BEGIN
    :NEW.PARENT_ID := PARENT_ID_SEQ.nextval;
END;
/



/*-------------------[[ PARENT_HISTORY INSERT TRIGGER

INCREMENTS THE SURROGATE KEY */

CREATE OR REPLACE TRIGGER P_HIST_ON_INSERT
    BEFORE INSERT ON PARENT_HISTORY
    FOR EACH ROW
DECLARE
    MAX_HISTORY_ID INTEGER;
BEGIN
    SELECT NVL(MAX(HISTORY_ID),0) INTO MAX_HISTORY_ID
    FROM PARENT_HISTORY
    GROUP BY CNIC
    HAVING CNIC = :NEW.CNIC;

    :NEW.HISTORY_ID := MAX_HISTORY_ID + 1;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        :NEW.HISTORY_ID := 1;
END;
/


/*----------------------- [[ GUARDIAN DDL ]] --------------------------*/

CREATE TABLE GUARDIAN
(
    GUARDIAN_ID INTEGER,
    CNIC VARCHAR2(13) NOT NULL,
    F_NAME VARCHAR2(32),
    L_NAME VARCHAR2(32),
    CONTACT_NO VARCHAR2(15),
    GENDER CHAR(1) NOT NULL,
    PRIMARY KEY(GUARDIAN_ID),
    CHECK (CNIC NOT LIKE '%[^0-9]%'),
    CHECK (CONTACT_NO NOT LIKE '%[^0-9]%'),
    CHECK (GENDER IN ('M', 'F')),
    UNIQUE(CNIC)
);

/*----------------------- [[ GUARDIAN_HISTORY DDL ]] --------------------------*/

CREATE TABLE GUARDIAN_HISTORY
(
    GUARDIAN_ID INTEGER,
    HISTORY_ID INTEGER,
    CNIC VARCHAR2(13),
    F_NAME VARCHAR2(32),
    L_NAME VARCHAR2(32),
    CONTACT_NO VARCHAR2(15),
    GENDER CHAR(1),
    PRIMARY KEY(GUARDIAN_ID, HISTORY_ID),
    FOREIGN KEY(GUARDIAN_ID) REFERENCES GUARDIAN(GUARDIAN_ID)
);


/*-------------- [[ GUARDIAN INSERT & UPDATE TRIGGER*/

CREATE SEQUENCE GUARDIAN_ID_SEQ START WITH 5000;

CREATE OR REPLACE TRIGGER GUARDIAN_ON_INSERT
    BEFORE INSERT ON GUARDIAN
    FOR EACH ROW
BEGIN
    :NEW.GUARDIAN_ID := GUARDIAN_ID_SEQ.NEXTVAL;

EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error! Unhandled exception in Trigger: GUARDIAN_ON_INSERT');
END;
/

CREATE OR REPLACE TRIGGER GUARDIAN_AFTER_INSERT
    AFTER INSERT ON GUARDIAN
    FOR EACH ROW
DECLARE
    CUR_G_ID INTEGER;
BEGIN
    /*RECORD INSERTION IN GUARDIAN_HISTORY*/

    INSERT INTO GUARDIAN_HISTORY
    VALUES(:NEW.GUARDIAN_ID, 0, :NEW.CNIC, :NEW.F_NAME, :NEW.L_NAME, :NEW.CONTACT_NO, :NEW.GENDER);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error! Unhandled exception in Trigger: GUARDIAN_AFTER_INSERT');
END;
/

CREATE OR REPLACE TRIGGER GUARDIAN_UPDATE
    AFTER UPDATE ON GUARDIAN
    FOR EACH ROW
DECLARE
    CUR_G_ID INTEGER;
BEGIN
    /*RECORD UPDATE IN GUARDIAN_HISTORY*/

    INSERT INTO GUARDIAN_HISTORY
    VALUES(:NEW.GUARDIAN_ID, 0, :NEW.CNIC, :NEW.F_NAME, :NEW.L_NAME, :NEW.CONTACT_NO, :NEW.GENDER);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error! Unhandled exception in Trigger: GUARDIAN_UPDATE');
END;
/



/*------------- GUARDIAN_HISTORY INSERT TRIGGER

INCREMENTS SURROGATE KEY */

CREATE OR REPLACE TRIGGER G_HIST_ON_INSERT
    BEFORE INSERT ON GUARDIAN_HISTORY
    FOR EACH ROW
DECLARE
    MAX_HISTORY_ID INTEGER;
BEGIN
    SELECT NVL(MAX(HISTORY_ID),0) INTO MAX_HISTORY_ID
    FROM GUARDIAN_HISTORY
    GROUP BY GUARDIAN_ID
    HAVING GUARDIAN_ID = :NEW.GUARDIAN_ID;

    :NEW.HISTORY_ID := MAX_HISTORY_ID + 1;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        :NEW.HISTORY_ID := 1;
END;
/






/*-----------------------[[ CLASS DDL ]] ----------------------------*/

CREATE TABLE CLASS
(
    CLASS_ID INTEGER,
    CO_ED NUMERIC(1),
    REQ_GUARD NUMERIC(1),
    MIN_AGE NUMERIC(2),
    MAX_AGE NUMERIC(2),
    CHECK (CO_ED IN (0,1)),
    CHECK (REQ_GUARD IN (0,1)),
    PRIMARY KEY(CLASS_ID)
);

/*-----------------------[[ SECTION DDL ]] -------------------------*/

CREATE TABLE SECTION
(
    CLASS_ID INTEGER,
    SECTION_ID CHAR(1),
    TITLE VARCHAR2(8) UNIQUE,
    GENDER_RESTRAINT CHAR(1),
    PRIMARY KEY(CLASS_ID, SECTION_ID),
    FOREIGN KEY (CLASS_ID) REFERENCES CLASS(CLASS_ID),
    CHECK (SECTION_ID NOT LIKE '%[^A-Z]%'),
    CHECK (GENDER_RESTRAINT IN (NULL, 'M', 'F'))
);

/*---------------------------[[ SECTION INSERT TRIGGER*/

CREATE OR REPLACE TRIGGER SECTION_ON_INSERT
    BEFORE INSERT ON SECTION
    FOR EACH ROW
DECLARE
    IS_CO_ED NUMERIC(1);
BEGIN
    /*SETS GENDER_RESTRAINT = NULL IF CLASS IS CO-ED*/

    SELECT CO_ED INTO IS_CO_ED
    FROM CLASS
    WHERE CLASS_ID = :NEW.CLASS_ID;

    IF IS_CO_ED = 1 THEN
        :NEW.GENDER_RESTRAINT := NULL;
    END IF;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Error! This class does not exist.');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error! Unhandled exception in Trigger: SECTION_ON_INSERT');
END;
/









/*----------------------- [[ FAMILY DDL ]] --------------------------*/

CREATE TABLE FAMILY
(
    FAMILY_ID INTEGER,
    FATHER_ID INTEGER,
    MOTHER_ID INTEGER,
    NUM_CHILDREN NUMBER(3) DEFAULT 0,
    SP_DISCOUNT NUMBER(3),
    JOIN_DATE DATE,
    EARLY_INTRODUCER NUMERIC(1) DEFAULT 0,
    CHECK (SP_DISCOUNT BETWEEN 0 AND 100),
    PRIMARY KEY(FAMILY_ID),
    UNIQUE(FATHER_ID, MOTHER_ID),
    FOREIGN KEY (FATHER_ID) REFERENCES PARENT(PARENT_ID),
    FOREIGN KEY (MOTHER_ID) REFERENCES PARENT(PARENT_ID)
);


/*FAMILY_ID SEQUENCE*/

CREATE SEQUENCE FAMILY_ID_SEQ START WITH 3260 INCREMENT BY 13;


/*---------------------------[[ FAMILY INSERT & UPDATE TRIGGERS */

CREATE OR REPLACE TRIGGER FAMILY_ON_INSERT
    BEFORE INSERT ON FAMILY
    FOR EACH ROW
DECLARE
    M_TYPE NUMERIC(1);
    F_TYPE NUMERIC(1);
    FGENDER CHAR(1);
    MGENDER CHAR(1);
    FATHER_GENDER_MISMATCH EXCEPTION;
    PRAGMA EXCEPTION_INIT(FATHER_GENDER_MISMATCH, -20311);
    MOTHER_GENDER_MISMATCH EXCEPTION;
    PRAGMA EXCEPTION_INIT(MOTHER_GENDER_MISMATCH, -20312);
BEGIN
    /*IF EITHER PARENT IS TEACHER, SET SP_DISCOUNT = 100*/

    SELECT PE.GENDER, PE.P_TYPE INTO MGENDER, M_TYPE
    FROM PARENT P
    INNER JOIN PERSON PE ON P.CNIC = PE.CNIC
    WHERE P.PARENT_ID = :NEW.MOTHER_ID;

    SELECT PE.GENDER, PE.P_TYPE INTO FGENDER, F_TYPE
    FROM PARENT P
    INNER JOIN PERSON PE ON P.CNIC = PE.CNIC
    WHERE P.PARENT_ID = :NEW.FATHER_ID;

    IF FGENDER <> 'M' THEN
        RAISE_APPLICATION_ERROR(-20311, 'Father must be Male');
    ELSIF MGENDER <> 'F' THEN
        RAISE_APPLICATION_ERROR(-20312, 'Mother must be Female');
    END IF;

    :NEW.FAMILY_ID := FAMILY_ID_SEQ.NEXTVAL;

    IF M_TYPE = 2 OR F_TYPE = 2 THEN
        :NEW.SP_DISCOUNT := 100;
    END IF;
END;
/


CREATE OR REPLACE TRIGGER FAMILY_BEFORE_UPDATE
    BEFORE UPDATE ON FAMILY
    FOR EACH ROW
BEGIN
    /*IF NUM_CHILDREN > 3 - GIVE DISCOUNT*/

    IF :NEW.NUM_CHILDREN > 3 THEN
        :NEW.SP_DISCOUNT := 30;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error! Unhandled exception in Trigger: FAMILY_BEFORE_UPDATE');
END;
/











/*----------------------- [[ STUDENT DDL ]] --------------------------*/

CREATE TABLE STUDENT
(
    STUDENT_ID INTEGER,
    CNIC VARCHAR2(13),
    F_NAME VARCHAR2(32),
    L_NAME VARCHAR2(32),
    DOB DATE,
    GENDER CHAR(1) NOT NULL,
    PICTURE BFILE,
    CLASS_ID INTEGER,
    SECTION_ID CHAR(1),
    FAMILY_ID INTEGER,
    GUARDIAN_ID INTEGER,
    RELATION VARCHAR2(32),
    CHALLAN_ID VARCHAR2(15),
    ADMIT_DATE DATE,
    LAST_UPDATE_DATE DATE,
    PRIMARY KEY(STUDENT_ID),
    UNIQUE(CNIC),
    FOREIGN KEY (CLASS_ID, SECTION_ID) REFERENCES SECTION (CLASS_ID, SECTION_ID),
    FOREIGN KEY (FAMILY_ID) REFERENCES FAMILY(FAMILY_ID)
);

/*----------------------- [[ STUDENT_HISTORY DDL ]] --------------------------*/

CREATE TABLE STUDENT_HISTORY
(
    STUDENT_ID INTEGER,
    HISTORY_ID INTEGER,
    CNIC VARCHAR2(13),
    F_NAME VARCHAR2(32),
    L_NAME VARCHAR2(32),
    DOB DATE,
    GENDER CHAR(1),
    PICTURE BFILE,
    CLASS_ID INTEGER,
    SECTION_ID CHAR(1),
    FAMILY_ID INTEGER,
    GUARDIAN_ID INTEGER,
    RELATION VARCHAR2(32),
    CHALLAN_ID VARCHAR2(15),
    NEW_ADMIT_OR_CLASS_CHANGE NUMERIC(1),
    ADMIT_DATE DATE NOT NULL,
    LAST_UPDATE_DATE DATE NOT NULL,
    PRIMARY KEY (STUDENT_ID, HISTORY_ID)
);

/*------------- [[ STUDENT INSERT, DELETE & UPDATE TRIGGERS*/

CREATE SEQUENCE STUDENT_ID_SEQ START WITH 10000 INCREMENT BY 17;

CREATE OR REPLACE TRIGGER STUDENT_ON_INSERT
    BEFORE INSERT ON STUDENT
    FOR EACH ROW
DECLARE
    MIN_AGE_NOT_MET EXCEPTION; PRAGMA EXCEPTION_INIT(MIN_AGE_NOT_MET, -20111);
    MAX_AGE_EXCEEDED EXCEPTION; PRAGMA EXCEPTION_INIT(MAX_AGE_EXCEEDED, -20112);
    GENDER_MISMATCH EXCEPTION; PRAGMA EXCEPTION_INIT(GENDER_MISMATCH, -20113);
    GUARDIAN_IS_MALE EXCEPTION; PRAGMA EXCEPTION_INIT(GUARDIAN_IS_MALE, -20114);
    OTHER_EXCEP EXCEPTION; PRAGMA EXCEPTION_INIT(OTHER_eXCEP, -20115);
    MIN_AGE_ALLOWED NUMERIC(2);
    MAX_AGE_ALLOWED NUMERIC(2);
    GENDER_RESTRAINT_A CHAR(1);
    REQ_GUARD_A NUMERIC(1);
    GUARD_GENDER CHAR(1);
    AGE NUMERIC(4,2);
BEGIN

    /*------------[[ RETRIVES RELEVANT SECTION + CLASS INFORMATION */
    SELECT CLASS.REQ_GUARD, CLASS.MIN_AGE, CLASS.MAX_AGE, SECTION.GENDER_RESTRAINT INTO REQ_GUARD_A, MIN_AGE_ALLOWED, MAX_AGE_ALLOWED, GENDER_RESTRAINT_A
    FROM SECTION
    INNER JOIN CLASS
    ON SECTION.CLASS_ID = CLASS.CLASS_ID
    WHERE SECTION.CLASS_ID = :NEW.CLASS_ID AND SECTION.SECTION_ID = :NEW.SECTION_ID;

    SELECT GENDER INTO GUARD_GENDER
    FROM GUARDIAN
    WHERE GUARDIAN_ID = :NEW.GUARDIAN_ID;

    AGE := ROUND(MONTHS_BETWEEN(SYSDATE(),:NEW.DOB)/12,2);


    /*------------[[ RAISES EXCEPTIONS IF CERTAIN PARAMETERS ARE ILLEGAL*/
    /*------------[[ ERROR CODE IDENTIFIED IN PHP FOR ERROR MESSAGE*/

    IF REQ_GUARD_A <> 0 AND GUARD_GENDER = 'M' THEN
        RAISE_APPLICATION_ERROR(-20114, 'Error! Guardian can not be Male');
    ELSIF AGE < MIN_AGE_ALLOWED THEN
        RAISE_APPLICATION_ERROR(-20111, 'Error! Student is too young for this class - Trigger: STUDENT_ON_INSERT');
    ELSIF AGE >= MAX_AGE_ALLOWED THEN
        RAISE_APPLICATION_ERROR(-20112, 'Error! Student is too old for this class - Trigger: STUDENT_ON_INSERT');
    ELSIF :NEW.GENDER <> NVL(GENDER_RESTRAINT_A,:NEW.GENDER) THEN
        RAISE_APPLICATION_ERROR(-20113, 'Error! This section is not CO-ED - Trigger: STUDENT_ON_INSERT');
    ELSE
        :NEW.STUDENT_ID := STUDENT_ID_SEQ.NEXTVAL;
    END IF;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
         RAISE_APPLICATION_ERROR(-20115, 'Guardian/Section does not exist');
END;
/



CREATE OR REPLACE TRIGGER STUDENT_AFTER_INSERT
    AFTER INSERT ON STUDENT
    FOR EACH ROW
DECLARE
    MIN_AGE_ALLOWED NUMERIC(2);
BEGIN

    SELECT MIN_AGE INTO MIN_AGE_ALLOWED FROM CLASS WHERE CLASS_ID = :NEW.CLASS_ID;

    /*-----------[[ SETS EARLY_INTRODUCER FLAG APPROPRIATELY, UPDATES FAMILY.NUM_CHILDREN*/

    IF ROUND(MONTHS_BETWEEN(SYSDATE(), :NEW.DOB)/12,0) = MIN_AGE_ALLOWED THEN
        UPDATE FAMILY
        SET EARLY_INTRODUCER = 1,
            NUM_CHILDREN = NUM_CHILDREN + 1
        WHERE FAMILY_ID = :NEW.FAMILY_ID;
    ELSE
        UPDATE FAMILY
        SET NUM_CHILDREN = NUM_CHILDREN + 1
        WHERE FAMILY_ID = :NEW.FAMILY_ID;
    END IF;

    INSERT INTO STUDENT_HISTORY
    VALUES(:NEW.STUDENT_ID, 0, :NEW.CNIC, :NEW.F_NAME, :NEW.L_NAME, :NEW.DOB, :NEW.GENDER, :NEW.PICTURE, :NEW.CLASS_ID, :NEW.SECTION_ID, :NEW.FAMILY_ID, :NEW.GUARDIAN_ID, :NEW.RELATION, :NEW.CHALLAN_ID, 1, :NEW.ADMIT_DATE, :NEW.LAST_UPDATE_DATE);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error! Unhandled exception in Trigger: STUDENT_AFTER_INSERT');
END;
/



CREATE OR REPLACE TRIGGER STUDENT_AFTER_DELETE
    AFTER DELETE ON STUDENT
    FOR EACH ROW
BEGIN
    /*---------[[ UPDATES FAMILY.NUM_CHILDREN*/

    UPDATE FAMILY
    SET NUM_CHILDREN = NUM_CHILDREN - 1
    WHERE FAMILY_ID = :OLD.FAMILY_ID;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error! Unhandled exception in Trigger: STUDENT_AFTER_DELETE');
END;
/


/*NEW_ADMIT_OR_CLASS_CHANGE IS 0: CLASS WASNT CHANGED, 1: NEW INSERT, 2: CLASS WAS UPDATED*/

CREATE OR REPLACE TRIGGER STUDENT_UPDATE
    AFTER UPDATE ON STUDENT
    FOR EACH ROW
DECLARE
    MIN_AGE_NOT_MET EXCEPTION; PRAGMA EXCEPTION_INIT(MIN_AGE_NOT_MET, -20111);
    MAX_AGE_EXCEEDED EXCEPTION; PRAGMA EXCEPTION_INIT(MAX_AGE_EXCEEDED, -20112);
    GENDER_MISMATCH EXCEPTION; PRAGMA EXCEPTION_INIT(GENDER_MISMATCH, -20113);
    GUARDIAN_IS_MALE EXCEPTION; PRAGMA EXCEPTION_INIT(GUARDIAN_IS_MALE, -20114);
    MIN_AGE_ALLOWED NUMERIC(2);
    MAX_AGE_ALLOWED NUMERIC(2);
    GENDER_RESTRAINT_A CHAR(1);
    REQ_GUARD_A NUMERIC(1);
    GUARD_GENDER CHAR(1);
    AGE NUMERIC(4,2);
    CUR_S_ID INTEGER;
    NEW_OR_UPDATE NUMERIC(1);
BEGIN

    /*SAME AS INSERT - RAISES EXCEPTIONS AND SELECTS NEW_ADMIT_OR_CLASS_CHANGE FLAG*/

    IF :OLD.CLASS_ID <> :NEW.CLASS_ID OR :OLD.SECTION_ID <> :NEW.SECTION_ID THEN
        SELECT CLASS.REQ_GUARD, CLASS.MIN_AGE, CLASS.MAX_AGE, SECTION.GENDER_RESTRAINT INTO REQ_GUARD_A, MIN_AGE_ALLOWED, MAX_AGE_ALLOWED, GENDER_RESTRAINT_A
        FROM SECTION
        INNER JOIN CLASS
        ON SECTION.CLASS_ID = CLASS.CLASS_ID
        WHERE SECTION.CLASS_ID = :NEW.CLASS_ID AND SECTION.SECTION_ID = :NEW.SECTION_ID;

        SELECT GENDER INTO GUARD_GENDER
        FROM GUARDIAN
        WHERE GUARDIAN_ID = :NEW.GUARDIAN_ID;

        AGE := ROUND(MONTHS_BETWEEN(SYSDATE(),:NEW.DOB)/12,2);

        IF REQ_GUARD_A <> 0 AND GUARD_GENDER = 'M' THEN
        RAISE_APPLICATION_ERROR(-20114, 'Error! Guardian can not be Male');
        ELSIF AGE < MIN_AGE_ALLOWED THEN
            RAISE_APPLICATION_ERROR(-20111, 'Error! Student is too young for this class - Trigger: STUDENT_ON_INSERT');
        ELSIF AGE >= MAX_AGE_ALLOWED THEN
            RAISE_APPLICATION_ERROR(-20112, 'Error! Student is too old for this class - Trigger: STUDENT_ON_INSERT');
        ELSIF :NEW.GENDER <> NVL(GENDER_RESTRAINT_A,:NEW.GENDER) THEN
            RAISE_APPLICATION_ERROR(-20113, 'Error! This section is not CO-ED - Trigger: STUDENT_ON_INSERT');
        END IF;
        
    END IF;

    IF :OLD.CLASS_ID = :NEW.CLASS_ID AND :OLD.SECTION_ID = :NEW.SECTION_ID THEN
        NEW_OR_UPDATE := 0;
    ELSE
        NEW_OR_UPDATE := 2;
    END IF;

    INSERT INTO STUDENT_HISTORY
    VALUES(:NEW.STUDENT_ID, 0, :NEW.CNIC, :NEW.F_NAME, :NEW.L_NAME, :NEW.DOB, :NEW.GENDER, :NEW.PICTURE, :NEW.CLASS_ID, :NEW.SECTION_ID, :NEW.FAMILY_ID, :NEW.GUARDIAN_ID, :NEW.RELATION, :NEW.CHALLAN_ID, NEW_OR_UPDATE, :NEW.ADMIT_DATE, :NEW.LAST_UPDATE_DATE);
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Error! NO_DATA_FOUND in Trigger: STUDENT_UPDATE');
END;
/



/*----------------- [[ STUDENT_HISTORY INSERT TRIGGER
INCREMENTS SURROGATE KEY */

CREATE OR REPLACE TRIGGER S_HIST_ON_INSERT
    BEFORE INSERT ON STUDENT_HISTORY
    FOR EACH ROW
DECLARE
    MAX_HISTORY_ID INTEGER;
BEGIN
    SELECT NVL(MAX(HISTORY_ID),0) INTO MAX_HISTORY_ID
    FROM STUDENT_HISTORY
    GROUP BY STUDENT_ID
    HAVING STUDENT_ID = :NEW.STUDENT_ID;

    :NEW.HISTORY_ID := MAX_HISTORY_ID + 1;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        :NEW.HISTORY_ID := 1;
END;
/







/*----------------------- [[ ACCOMPANYING DDL ]] --------------------------*/


CREATE TABLE ACCOMPANYING
(
    STUDENT_ID INTEGER,
    TOKEN_NO INTEGER,
    GUARDIAN_ID INTEGER NOT NULL,  
    PREGNANT NUMERIC(1) DEFAULT 0,
    REASON VARCHAR2(64),
    PRIMARY KEY (STUDENT_ID, TOKEN_NO),
    FOREIGN KEY (STUDENT_ID) REFERENCES STUDENT(STUDENT_ID),
    FOREIGN KEY (GUARDIAN_ID) REFERENCES GUARDIAN(GUARDIAN_ID)
);

CREATE OR REPLACE TRIGGER ACCOMPANYING_BEFORE_INSERT
    BEFORE INSERT ON ACCOMPANYING
    FOR EACH ROW
DECLARE
    MAX_TOKEN_NO INTEGER;
    GID INTEGER;
    GUARDIAN_MISMATCH EXCEPTION;
    PRAGMA EXCEPTION_INIT(GUARDIAN_MISMATCH,-20211);
BEGIN
    /*RAISES EXCEPTION IF GUARDIAN ID GIVEN DOESNT BELONG TO STUDENT*/

    SELECT GUARDIAN_ID INTO GID
    FROM STUDENT
    WHERE STUDENT_ID = :NEW.STUDENT_ID;

    IF GID <> :NEW.GUARDIAN_ID THEN
        RAISE_APPLICATION_ERROR(-20211, 'Guardian Mismatch');
    END IF;


    /*SET HISTORY_ID SURROGATE KEY*/

    SELECT MAX(TOKEN_NO) INTO MAX_TOKEN_NO
    FROM ACCOMPANYING
    GROUP BY STUDENT_ID
    HAVING STUDENT_ID = :NEW.STUDENT_ID;

    :NEW.TOKEN_NO := MAX_TOKEN_NO + 1;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        :NEW.TOKEN_NO := 1;
END;
/












/*----------[[ SELECT STATEMENTS TO VIEW DATASET ]] -------------------*/


SELECT CNIC, F_NAME||' '||L_NAME AS NAME, CONTACT_NO, GENDER, P_TYPE
FROM PERSON
ORDER BY CNIC;

SELECT * FROM STAFF ORDER BY STAFF_ID;

SELECT * FROM PARENT ORDER BY PARENT_ID;

SELECT PARENT_ID, HISTORY_ID, CNIC, F_NAME||' '||L_NAME AS NAME, CONTACT_NO, GENDER
FROM PARENT_HISTORY
ORDER BY PARENT_ID, HISTORY_ID;




SELECT * FROM GUARDIAN_ID ORDER BY GUARDIAN_ID;

SELECT * FROM GUARDIAN_HISTORY ORDER BY GUARDIAN_ID, HISTORY_ID;



SELECT * FROM CLASS ORDER BY CLASS_ID;

SELECT * FROM SECTION ORDER BY CLASS_ID, SECTION_ID;


SELECT * FROM FAMILY ORDER BY FAMILY_ID;

SELECT STUDENT_ID, CNIC, F_NAME||' '||L_NAME, DOB, GENDER, CLASS_ID, SECTION_ID, FAMILY_ID, GUARDIAN_ID, RELATION, CHALLAN_ID, ADMIT_DATE, LAST_UPDATE_DATE FROM STUDENT ORDER BY STUDENT_ID;

SELECT STUDENT_ID, HISTORY_ID, CNIC, F_NAME||' '||L_NAME, DOB, GENDER, CLASS_ID, SECTION_ID, FAMILY_ID, GUARDIAN_ID, RELATION, CHALLAN_ID, ADMIT_DATE, LAST_UPDATE_DATE, NEW_ADMIT_OR_CLASS_CHANGE 
FROM STUDENT_HISTORY 
ORDER BY STUDENT_ID, HISTORY_ID;


SELECT * FROM ACCOMPANYING ORDER BY STUDENT_ID, TOKEN_NO;








/*----------[[ DROP EVERYTHING ]] ------------------*/

DROP TABLE ACCOMPANYING;

DROP TABLE STUDENT_HISTORY;
DROP TABLE STUDENT;
DROP SEQUENCE STUDENT_ID_SEQ;

DROP TABLE FAMILY;
DROP SEQUENCE FAMILY_ID_SEQ;

DROP TABLE SECTION; 
DROP TABLE CLASS;

DROP TABLE GUARDIAN_HISTORY;
DROP TABLE GUARDIAN;
DROP SEQUENCE GUARDIAN_ID_SEQ;

DROP TABLE PARENT_HISTORY;
DROP TABLE PARENT;
DROP SEQUENCE PARENT_ID_SEQ;
DROP TABLE STAFF;
DROP SEQUENCE STAFF_ID_SEQ;
DROP TABLE PERSON;